"""
Functions to apply lensing to batches of input T maps, using lenstools.

This was used for versions 1-5, after which there are specific per-version data generation scripts.
"""

import time

import astropy
import healpy as hp
import lenstools
import matplotlib.pyplot as plt
import numpy as np


def single_tmap_png():
    """
    Lens a single tmap with different kappa maps, saved as png files.

    Kappa maps are multiplied by a kappa_exaggeration_factor prior to lensing.
    """

    # Parameters
    unlensed_tmap_path = 'path/to/unlensed_tmap.npz' # generated by generate_flat_maps.generate_unlensed_tmaps
    kappa_maps_path = 'path/to/kappa_maps.npz' # generated by generate_flat_maps.generate_kappa_maps
    kappa_exaggeration_factor = 30
    npix = 50
    nside_equiv = 128
    lx = npix * np.sqrt(hp.nside2pixarea(nside_equiv)) * astropy.units.rad
    t_save_dir = '/path/to/save/lensed_t_maps/'
    t_save_min = -30000 # normalisation for the png colour scale
    t_save_max = 30000
    k_save_dir = '/path/to/save/kappa_maps/'
    k_save_min = -1 # normalisation for the png colour scale
    k_save_max = 1

    # Load and initialise unlensed T map
    with np.load(unlensed_tmap_path) as data:
        unlensed_tmap_data = np.squeeze(data['tmaps'])
    assert unlensed_tmap_data.shape == (npix, npix)
    microkelvin = 1e-6 * astropy.units.K
    unlensed_tmap = lenstools.image.convergence.CMBTemperatureMap(unlensed_tmap_data, lx, npixel=npix,
                                                                  space='real', unit=microkelvin)

    # Load kappa maps
    with np.load(kappa_maps_path) as data:
        kappa_maps_data = data['kapmaps']
    n_real = kappa_maps_data.shape[0]
    assert kappa_maps_data.shape == (n_real, npix, npix)

    # Exaggerate lensing
    kappa_maps_data *= kappa_exaggeration_factor

    # Loop through kappa realisations
    for i, kappa_map_data in enumerate(kappa_maps_data):
        print(f'Processing map {i + 1} / {n_real}')

        # Initialise kappa map
        kappa_map = lenstools.image.convergence.ConvergenceMap(kappa_map_data, lx, npixel=npix)

        # Lens
        lensed_tmap = unlensed_tmap.lens(kappa_map)

        # # Plot
        # _, ax = plt.subplots(ncols=4)
        # ax[0].imshow(unlensed_tmap.data)
        # ax[1].imshow(lensed_tmap.data)
        # ax[2].imshow(lensed_tmap.data - unlensed_tmap.data)
        # ax[3].imshow(kappa_map.data)
        # plt.show()

        # Save lensed T map
        assert t_save_min < np.amin(lensed_tmap.data) < np.amax(lensed_tmap.data) < t_save_max
        t_save_path = f'{t_save_dir}lensed_{i}.png'
        plt.imsave(t_save_path, lensed_tmap.data, vmin=t_save_min, vmax=t_save_max, cmap='Greys')

        # Save corresponding kappa map
        assert k_save_min < np.amin(kappa_map.data) < np.amax(kappa_map.data) < k_save_max
        k_save_path = f'{k_save_dir}kappa_{i}.png'
        plt.imsave(k_save_path, kappa_map.data, vmin=k_save_min, vmax=k_save_max, cmap='Greys')


def different_tmaps_png():
    """
    Use a different Tmap for each kappa map, saved as png files.

    Kappa maps are multiplied by a kappa_exaggeration_factor prior to lensing.
    """

    # Parameters
    unlensed_tmaps_path = 'path/to/unlensed_tmaps.npz' # generated by generate_flat_maps.generate_unlensed_tmaps
    kappa_maps_path = 'path/to/kappa_maps.npz' # generated by generate_flat_maps.generate_kappa_maps
    kappa_exaggeration_factor = 10
    npix = 50
    nside_equiv = 128
    lx = npix * np.sqrt(hp.nside2pixarea(nside_equiv)) * astropy.units.rad
    t_save_dir = '/path/to/save/lensed_t_maps/'
    t_save_min = -30000 # normalisation for the png colour scale
    t_save_max = 30000
    k_save_dir = '/path/to/save/kappa_maps/'
    k_save_min = -1 # normalisation for the png colour scale
    k_save_max = 1

    print(f'lx = {lx}')

    # Load unlensed T maps
    with np.load(unlensed_tmaps_path) as data:
        unlensed_tmaps_data = data['tmaps']
    n_real = unlensed_tmaps_data.shape[0]
    assert unlensed_tmaps_data.shape == (n_real, npix, npix)
    microkelvin = 1e-6 * astropy.units.K

    # Load kappa maps
    with np.load(kappa_maps_path) as data:
        kappa_maps_data = data['kapmaps']
    assert kappa_maps_data.shape == (n_real, npix, npix)

    # Exaggerate lensing
    kappa_maps_data *= kappa_exaggeration_factor

    tmin = np.Inf
    tmax = np.NINF
    kmin = np.Inf
    kmax = np.NINF

    # Loop through realisations
    for i, (unlensed_tmap_data, kappa_map_data) in enumerate(zip(unlensed_tmaps_data, kappa_maps_data)):
        print(f'Processing map {i + 1} / {n_real}')

        # Initialise maps
        unlensed_tmap = lenstools.image.convergence.CMBTemperatureMap(unlensed_tmap_data, lx, npixel=npix,
                                                                      space='real', unit=microkelvin)
        kappa_map = lenstools.image.convergence.ConvergenceMap(kappa_map_data, lx, npixel=npix)

        # Lens
        lensed_tmap = unlensed_tmap.lens(kappa_map)

        # # Plot
        # _, ax = plt.subplots(ncols=4)
        # ax[0].imshow(unlensed_tmap.data)
        # ax[1].imshow(lensed_tmap.data)
        # ax[2].imshow(lensed_tmap.data - unlensed_tmap.data)
        # ax[3].imshow(kappa_map.data)
        # plt.show()

        # Measure min and max
        tmin = np.amin((tmin, np.amin(lensed_tmap.data)))
        tmax = np.amax((tmax, np.amax(lensed_tmap.data)))
        kmin = np.amin((kmin, np.amin(kappa_map.data)))
        kmax = np.amax((kmax, np.amax(kappa_map.data)))

        # Save lensed T map
        assert t_save_min < np.amin(lensed_tmap.data) < np.amax(lensed_tmap.data) < t_save_max, \
               (np.amin(lensed_tmap.data), np.amax(lensed_tmap.data))
        t_save_path = f'{t_save_dir}lensed_{i}.png'
        plt.imsave(t_save_path, lensed_tmap.data, vmin=t_save_min, vmax=t_save_max, cmap='Greys')

        # Save corresponding kappa map
        assert k_save_min < np.amin(kappa_map.data) < np.amax(kappa_map.data) < k_save_max
        k_save_path = f'{k_save_dir}kappa_{i}.png'
        plt.imsave(k_save_path, kappa_map.data, vmin=k_save_min, vmax=k_save_max, cmap='Greys')

    print('Final tmin =', tmin, ', tmax =', tmax)
    print('Final kmin =', kmin, ', kmax =', kmax)


def different_tmaps_npz():
    """
    Use a different Tmap for each kappa map, saved as a single npz file.

    Kappa maps are multiplied by a kappa_exaggeration_factor prior to lensing.
    """

    # Parameters
    n_samp = 10 # number of samples
    unlensed_tmaps_path = 'path/to/unlensed_tmaps.npz' # generated by generate_flat_maps.generate_unlensed_tmaps
    kappa_maps_path = 'path/to/kappa_maps.npz' # generated by generate_flat_maps.generate_kappa_maps
    kappa_exaggeration_factor = 1
    npix = 50
    nside_equiv = 8192
    lx = npix * np.sqrt(hp.nside2pixarea(nside_equiv)) * astropy.units.rad
    save_path = 'path/to/save/output.npz'
    t_scale = 5.5e-5 # max abs value to normalise output maps
    k_scale = 0.73

    print(f'lx = {lx.to(astropy.units.deg)}') # pylint: disable=no-member

    # Load unlensed T maps
    with np.load(unlensed_tmaps_path) as data:
        unlensed_tmaps_data = data['tmaps']
    n_real = unlensed_tmaps_data.shape[0]
    assert unlensed_tmaps_data.shape == (n_real, npix, npix)
    microkelvin = 1e-6 * astropy.units.K

    # Load kappa maps
    with np.load(kappa_maps_path) as data:
        kappa_maps_data = data['kapmaps']
    assert kappa_maps_data.shape == (n_real, npix, npix)

    # Exaggerate lensing
    kappa_maps_data *= kappa_exaggeration_factor

    # Loop through realisations
    lensed_tmaps_data = np.full_like(kappa_maps_data, np.nan)
    for i, (unlensed_tmap_data, kappa_map_data) in enumerate(zip(unlensed_tmaps_data, kappa_maps_data)):
        print(f'Processing map {i + 1} / {n_real}', end='\r')

        # Initialise maps
        unlensed_tmap = lenstools.image.convergence.CMBTemperatureMap(unlensed_tmap_data, lx, npixel=npix,
                                                                      space='real', unit=microkelvin)
        kappa_map = lenstools.image.convergence.ConvergenceMap(kappa_map_data, lx, npixel=npix)

        # Lens
        lensed_tmap = unlensed_tmap.lens(kappa_map)

        # # Plot
        # _, ax = plt.subplots(ncols=4)
        # ax[0].imshow(unlensed_tmap.data)
        # ax[1].imshow(lensed_tmap.data)
        # ax[2].imshow(lensed_tmap.data - unlensed_tmap.data)
        # ax[3].imshow(kappa_map.data)
        # plt.show()

        lensed_tmaps_data[i] = lensed_tmap.data

    assert np.all(np.isfinite(lensed_tmaps_data))
    print()

    # Reshape to have a single final "channel"
    shape = (n_samp, npix, npix, 1)
    lensed = np.reshape(lensed_tmaps_data, shape)
    kappa = np.reshape(kappa_maps_data, shape)

    # Rescale to be between 0 and 1
    print('Lensed before: min', np.amin(lensed), ', max', np.amax(lensed))
    print('Kappa before: min', np.amin(kappa), ', max', np.amax(kappa))
    lensed = lensed / (2 * t_scale) + 0.5
    print('Lensed after: min', np.amin(lensed), ', max', np.amax(lensed))
    assert 0 < np.amin(lensed) < np.amax(lensed) < 1
    kappa = kappa / (2 * k_scale) + 0.5
    print('Kappa After: min', np.amin(kappa), ', max', np.amax(kappa))
    assert 0 < np.amin(kappa) < np.amax(kappa) < 1

    # Save to disk
    # pylint: disable=no-member
    header = (f'Output from {__file__} function different_tmaps_npz for input unlensed_tmaps_path = '
              f'{unlensed_tmaps_path}, kappa_maps_path = {kappa_maps_path}, kappa_exaggeration_factor = '
              f'{kappa_exaggeration_factor}, npix = {npix}, nside_equiv = {nside_equiv} '
              f'(lx = {lx.to(astropy.units.deg)}), t_scale = {t_scale}, k_scale = {k_scale}, at {time.strftime("%c")}')
    np.savez_compressed(save_path, lensed=lensed, kappa=kappa, header=header)
    print('Saved ' + save_path)


def single_kappa_npz():
    """
    Apply the same kappa map to multiple T maps and save as a npz.
    """

    # Parameters
    n_samp = 100
    unlensed_tmaps_path = 'path/to/unlensed_tmaps.npz' # generated by generate_flat_maps.generate_unlensed_tmaps
    kappa_map_path = 'path/to/kappa_map.npz' # generated by generate_flat_maps.generate_kappa_maps
    kappa_exaggeration_factor = 1
    npix = 50
    nside_equiv = 128
    lx = npix * np.sqrt(hp.nside2pixarea(nside_equiv)) * astropy.units.rad
    save_path = 'path/to/save/output.npz'
    t_scale = 35000 # max abs value to normalise output maps
    k_scale = 0.035

    print(f'lx = {lx}')

    # Load unlensed T maps
    with np.load(unlensed_tmaps_path) as data:
        unlensed_tmaps_data = data['tmaps']
    n_real = unlensed_tmaps_data.shape[0]
    assert unlensed_tmaps_data.shape == (n_real, npix, npix)
    microkelvin = 1e-6 * astropy.units.K

    # Load kappa map
    with np.load(kappa_map_path) as data:
        kappa_map_data = data['kapmaps']
    assert kappa_map_data.shape == (1, npix, npix)

    # Exaggerate lensing
    kappa_map_data *= kappa_exaggeration_factor

    # Initialise kappa map
    kappa_map = lenstools.image.convergence.ConvergenceMap(np.squeeze(kappa_map_data), lx, npixel=npix)

    # Loop through realisations
    lensed_tmaps_data = np.full_like(unlensed_tmaps_data, np.nan)
    for i, unlensed_tmap_data in enumerate(unlensed_tmaps_data):
        print(f'Processing map {i + 1} / {n_real}')

        # Initialise maps
        unlensed_tmap = lenstools.image.convergence.CMBTemperatureMap(unlensed_tmap_data, lx, npixel=npix,
                                                                      space='real', unit=microkelvin)

        # Lens
        lensed_tmap = unlensed_tmap.lens(kappa_map)

        # # Plot
        # _, ax = plt.subplots(ncols=4)
        # ax[0].imshow(unlensed_tmap.data)
        # ax[1].imshow(lensed_tmap.data)
        # ax[2].imshow(lensed_tmap.data - unlensed_tmap.data)
        # ax[3].imshow(kappa_map.data)
        # plt.show()

        lensed_tmaps_data[i] = lensed_tmap.data

    assert np.all(np.isfinite(lensed_tmaps_data))

    # Reshape to have a single final "channel"
    shape = (n_samp, npix, npix, 1)
    lensed = np.reshape(lensed_tmaps_data, shape)
    kappa_maps_data = np.repeat(kappa_map_data, n_samp, axis=0)
    kappa = np.reshape(kappa_maps_data, shape)

    # Rescale to be between 0 and 1
    print('Rescaling lensed')
    print('Before: min', np.amin(lensed), ', max', np.amax(lensed))
    lensed = lensed / (2 * t_scale) + 0.5
    print('After: min', np.amin(lensed), ', max', np.amax(lensed))
    assert 0 < np.amin(lensed) < np.amax(lensed) < 1
    print('Rescaling kappa')
    print('Before: min', np.amin(kappa), ', max', np.amax(kappa))
    kappa = kappa / (2 * k_scale) + 0.5
    print('After: min', np.amin(kappa), ', max', np.amax(kappa))
    assert 0 < np.amin(kappa) < np.amax(kappa) < 1

    # Save to disk
    header = (f'Output from {__file__} function single_kappa_npz for input unlensed_tmaps_path = '
              f'{unlensed_tmaps_path}, kappa_map_path = {kappa_map_path}, kappa_exaggeration_factor = '
              f'{kappa_exaggeration_factor}, npix = {npix}, nside_equiv = {nside_equiv} (lx = {lx}) at '
              f'{time.strftime("%c")}')
    np.savez_compressed(save_path, lensed=lensed, kappa=kappa, header=header)
    print('Saved '+ save_path)
